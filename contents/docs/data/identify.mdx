---
title: Identify
sidebar: Docs
showTitle: true
availability:
    free: full
    selfServe: full
    enterprise: full

---

Identify enables you to to track the same user across different devices, platforms (frontend and backend), and connect events from before and after they log in for the first time.

Identifying users is done using the `identify` method, together with a unique ID. It is available in both our frontend and backend SDKs, as well as our [POST API](/docs/api/post-only-endpoints).

<MultiLanguage selector="tabs">

```node
client.identify({
    distinctId: 'distinct_id',
    properties: {
        name: 'Max Hedgehog',
        email: 'max@hedgehogmail.com',
    },
})
```

```javascript
posthog.identify(
    'distinct_id',
    { email: 'max@hedgehogmail.com', name: 'Max Hedgehog' } 
    {}, 
);
```

```python
posthog.identify(
    'distinct_id',
    {
        'name': 'Max Hedgehog',
        'email': 'max@hedgehogmail.com'
    }
)
```

```php
PostHog::identify(array(
  'distinctId' => 'distinct_id',
  'properties' => array(
    'name' => 'Max Hedgehog'
    'email' => 'max@hedgehogmail.com',
  )
));
```

```ruby
posthog.identify({
  distinct_id: "distinct_id",
  properties: {
    name: "Max Hedgehog",
    email: "max@hedgehogmail.com"
  }
})
```

```go
client.Enqueue(posthog.Identify{
  DistinctId: "distinct_id",
  Properties: posthog.NewProperties().
    Set("name", "Max Hedgehog").
    Set("email", "max@hedgehogmail.com"),
})
```

```java
posthog.identify(
  "distinct_id",
  new HashMap<String, Object>() {
    {
      put("name", "Max Hedgehog");
      put("email", "max@hedgehogmail.com");
    }
  }
);
```

```bash
curl -v -L --header "Content-Type: application/json" -d '{
    "api_key": "<ph_project_api_key>",
    "timestamp": "2020-08-16 09:03:11.913767",
    "context": {},
    "distinct_id": "distinct_id",
    "$set": {},
    "event": "$identify"
}' https://app.posthog.com/capture/
```

</MultiLanguage>

> We don't recommend using emails as distinct IDs, as people changing their email will lead to extra complexity to maintaining data integrity. It is better to use database IDs or account IDs.

On your frontend, you should call identify as soon as you're able to. Typically, this is every time your app loads for the first time, or directly after your users log in. This ensures that events sent during your users' sessions are correctly associated with them. 

### Setting user properties

You'll notice that one of the parameters in the `identify` method is a `properties` object. This enables you to set [user properties](/docs/data/user-properties), which can be used in PostHog features such as [filters](/docs/product-analytics/trends#filtering-events-based-on-properties) or [cohorts](/docs/data/cohorts). 

> Whenever possible, we recommend passing in all user properties you have available each time you call identify, as this will ensure that their user profile on PostHog is up to date.

User properties can also be set using a `capture` and not only with `identify`. See our [user properties docs](/docs/data/user-properties) for more details on how to work with them and best practices.

## Alias

Sometimes, you may want to assign multiple distinct IDs to a single user. This is helpful in scenarios where your primary distinct ID may be inaccessible. For example, if a distinct ID which is typically used on the frontend is not available in certain parts of your backend code. In this case, you can use `alias` to assign another distinct ID to the same user:

In the below example, we assign the user with `distinct_id` another ID: `alias_id`. This means that any events submitted using either `distinct_id` or `alias_id` will be associated with the same user.

<MultiLanguage selector="tabs">

```node
client.alias({
    distinctId: 'distinct_id',
    alias: 'alias_id',
})
```

```javascript
posthog.alias('alias_id', 'distinct_id');
```

```python
posthog.alias('alias_id', 'distinct_id');
```

```php
PostHog::alias(array(
  'distinctId' => 'distinct_id',
  'alias' => 'alias_id'
));
```

```ruby
posthog.alias({
  distinct_id: "distinct_id",
  alias: "alias_id",
})
```

```go
client.Enqueue(posthog.Alias{
  DistinctId: "distinct_id",
  Alias: "alias_id",
})
```

```java
posthog.alias("distinct_id", "alias_id");
```

```bash
curl -v -L --header "Content-Type: application/json" -d '{
    "api_key": "<ph_project_api_key>",
    "properties": {
        "distinct_id": "distinct_id_one",
        "alias": "any_other_id"
    },
    "timestamp": "2020-08-16 09:03:11.913767",
    "event": "$create_alias"
}' https://app.posthog.com/capture/
```

</MultiLanguage>

There are two requirements when assigning an `alias_id`:

1. It cannot be associated with more than one `distinct_id`.
2. The `alias_id` **must not** be the `distinct_id` of any other user. For example:

<MultiLanguage selector="tabs">

```node
client.identify({
    distinctId: 'distinct_id_one',
    properties: {},
// ❌ Not possible. 
// You cannot use distinct_id_one as an alias for any_other_id
client.alias({
    distinctId: 'any_other_id',
    alias: 'distinct_id_one',
})
```

```javascript
posthog.identify('distinct_id_one');
// ❌ Not possible. 
// You cannot use distinct_id_one as an alias for any_other_id
client.alias({
    distinctId: 'any_other_id',
    alias: 'distinct_id_one',
})
```

```python
posthog.identify('distinct_id_one',{})
# ❌ Not possible
# You cannot use distinct_id_one as an alias for any_other_id
posthog.alias('distinct_id_one', 'any_other_id');
```

```php
PostHog::identify(array(
  'distinctId' => 'distinct_id_one',
  'properties' => array()
));
# ❌ Not possible
# You cannot use distinct_id_one as an alias for any_other_id
PostHog::alias(array(
  'distinctId' => 'any_other_id',
  'alias' => 'distinct_id_one'
));
```

```ruby
posthog.identify({
  distinct_id: "distinct_id_one",
  properties: {}
})
# ❌ Not possible
# You cannot use distinct_id_one as an alias for any_other_id
posthog.alias({
  distinct_id: "any_other_id",
  alias: "distinct_id_one",
})
```

```go
client.Enqueue(posthog.Identify{
  DistinctId: "distinct_id_one",
  Properties: posthog.NewProperties()
})
// ❌ Not possible
// You cannot use distinct_id_one as an alias for any_other_id
client.Enqueue(posthog.Alias{
  DistinctId: "any_other_id",
  Alias: "distinct_id_one",
})
```

```java
posthog.identify(
  "distinct_id_one",
  new HashMap<String, Object>()
);
// ❌ Not possible
// You cannot use distinct_id_one as an alias for any_other_id
posthog.alias("any_other_id", "distinct_id_one");
```

</MultiLanguage>

## Using identify on the frontend

In your frontend, all events within PostHog are associated with a specific person:
1. Either an **anonymous user** – i.e., if `identify` has not been called.
2. Or a **recognized user** – i.e., `identify` has been called..

When a user starts browsing your website or app, they'll be automatically assigned an **anonymous ID**, which is then stored locally and allows us to track anonymous users – even across different sessions. This anonymous ID is created using the user's device ID.

By using `identify`, you are associating the anonymous ID with the distinct ID that you have provided. This enables us to associate any past or future events with your user.

> Note that depending on your [persistence configuration](/docs/libraries/js#persistence), the anonymous ID may not be stored, and thus regenerated across sessions.

### How are properties managed when identifying anonymous users?

When an anonymous user is identified as `User A`, all the properties of the anonymous user are added to `User A`. If there is a conflict, the properties of `User A` are prioritized over the anonymous user. For example:

```js
client.identify({
    distinctId: 'user_A',
    properties: {
        name: 'User A',
        location: 'London',
        timezone: 'GMT',
    },
})

client.reset()

// as an anonymous user
posthog.people.set({ 
    name: 'Anonymous User',
    phone: '0800-POSTHOG' 
})

client.identify({
    distinctId: 'user_A',
    properties: {
        timezone: 'GMT+8',
    },
})

/* User A will now have properties:
{ 
  name: 'User A',
  location: 'London', 
  phone: '0800-POSTHOG', 
  timezone: 'GMT+8' 
}
*/
```

### Reset after logout

If a user logs out on your frontend, you should call `reset` to unlink any future events made on that device with that user. 

This is important if your users are sharing a computer, as otherwise all of those users will be grouped together into a single user due to shared cookies between sessions. **We strongly recommend you do this on logout even if you don't expect users to share a computer.**

You can do that like so:

```js
posthog.reset()
```

If you _also_ want to reset the `device_id` so that the device will be considered a new device in future events, you can pass `true` as an argument:

```js
posthog.reset(true)
```

## Considerations

Avoid using non-unique distinct IDs to identify users. Two common ways in which this can happen are:

- Your logic for generating IDs does not generate sufficiently strong IDs and you can end up with a clash where 2 users have the same ID.

- There's a bug, typo, or mistake in your code leading to most or all users being identified with generic IDs like `null`, `true`, or `distinctId`.

All of the above scenarios are highly problematic, as they will cause distinct users to be merged together in PostHog.

While implementing analytics with PostHog, make sure you avoid above pitfalls to maintain data integrity. PostHog also has a few built-in protections stopping the most common threats to data integrity:

- We do not allow identifying users with empty space strings of any length – e.g.,`' '`, `'       '`, etc.
- We do not allow identifying users with the following strings (case insensitive):
    - `anonymous`
    - `guest`
    - `distinctid`
    - `distinct_id`
    - `id`
    - `not_authenticated`
    - `email`
    - `undefined`
    - `true`
    - `false`

- We do not allow identifying users with the following strings (case sensitive):
  - `[object Object]` 
  - `NaN`
  - `None`
  - `none`
  - `null`
  - `0`
  
- An `alias_id` may not to be associated with more than one `distinct_id`.
- An `alias_id` must be unique and not equal to any `distinct_id`.

If we encounter an `identify` or `alias` event with one of the above problems, the following will happen:

- We process the event normally (it will be ingested and show up in the UI)
- We refuse to merge users and an ingestion warning will be logged (see [ingestion warnings](/manual/data-management#ingestion-warnings) for more details).
- The event will be only be tied to the user associated with `distinct_id`

### Duplicate users in PostHog

It may happen that, due to implementation issues, the same user in your product has multiple users in PostHog associated with them. In these cases, you can use `$merge_dangerously` to merge multiple PostHog users into a single user.
   
> **Warning:** Merging users with `merge_dangerously` is irreversible and has no safeguards! Be careful not to merge users who should not be merged together.
> 
> Due to the dangers, we don't recommend you merge users frequently, but rather as a one-off for recovering from implementation problems. We also encourage you to consider whether merging users is strictly necessary for your data integrity, or a 'nice to have'.

Merging users is done by sending a `$merge_dangerously` event:

<MultiLanguage selector="tabs">

```node
client.capture({
    distinctId: 'distinct_id_of_user_to_merge_into',
    event: '$merge_dangerously',
    properties: {
        alias: 'distinct_id_of_user_to_be_merged',
    },
})
```

```py
posthog.capture('distinct_id_of_user_to_merge_into', 
  '$merge_dangerously', 
  {'alias': 'distinct_id_of_user_to_be_merged'})
```

```go
client.Enqueue(posthog.Capture{
  DistinctId: "distinct_id_of_user_to_merge_into",
  Event:      "$merge_dangerously",
  Properties: posthog.NewProperties().
    Set("alias", "distinct_id_of_user_to_be_merged"),
})
```

```ruby
posthog.capture({
    distinct_id: 'distinct_id_of_user_to_merge_into',
    event: '$merge_dangerously',
    properties: {
        alias: 'distinct_id_of_user_to_be_merged'
    }
})
```

```bash
curl -v -L --header "Content-Type: application/json" -d '{
    "api_key": "<ph_project_api_key>",
    "properties": {
      "alias": "distinct_id_of_user_to_be_merged"
    },
    "timestamp": "2020-08-16 09:03:11.913767",
    "distinct_id": "distinct_id_of_user_to_merge_into",
    "event": "$merge_dangerously"
}' https://app.posthog.com/capture/
```

</MultiLanguage>

#### How are properties managed when merging users?

When a `User B` is merged into another `User A`, all the properties of the `User B` are added to `User A`. If there is a conflict, the properties of `User A` are prioritized over `User B`. For example:
```js
client.identify({
    distinctId: 'user_A',
    properties: {
        location: 'London',
        name: 'User A',
    },
})

client.identify({
    distinctId: 'user_B',
    properties: {
        name: 'User B',
        location: 'Rome',
        phone: '0800-POSTHOG',
    },
})

posthog.alias(
  'user_A', // distinct_id
  'user_B'  // alias_id
)

/* User B has merged into User A. User A will now have properties:
{ 
  name: 'User A',
  location: 'London', 
  phone: '0800-POSTHOG', 
}
*/
```